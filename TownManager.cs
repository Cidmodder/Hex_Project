using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Pathfinding;

public class TownManager : MonoBehaviour
{
	//list the size of the town to determine what they generate. 1 for village, 2 for town, 3 for city
	public int size = 1;
	public  string name = "";

	//list of resources around the town. look for these on spawn.
	public List<Transform> woods = new List<Transform>();
	public List<Transform> stones = new List<Transform>();
	public List<Transform> manas = new List<Transform>();
	public List<Transform> irons = new List<Transform>();

	//list of tiles around the town
	public List<Transform> tiles = new List<Transform>();
	public List<Transform> water = new List<Transform>();

	//list of variables the town keeps track of

	//pop size and any general pop info needed
	public int pop = 30;
	public int unemployed = 30;

	//needs. Generated by pop, jobs, buildings, quests, and tech
	public int foodNeed = 0;
	public int woodNeed = 0;
	public int stoneNeed = 0;
	public int ironNeed = 0;
	public int manaNeed = 0;
	public int hideNeed = 0;
	public int firewoodNeed = 0;
	public int leatherNeed = 0;
	public int planksNeed = 0;
	public int bricksNeed = 0;
	public int ironbarsNeed = 0;
	public int arrowsNeed = 0;
	public int bowsNeed = 0;
	public int armorNeed = 0; //needs editing for different blacksmith crafts
	public int weaponsNeed = 0; //ditto editing for blacksmith
	public int potionsNeed = 0;

	//produce. Generated by tiles, jobs, pop, quests, player, and tech
	public int foodMade = 0;
	public int woodMade = 0;
	public int stoneMade = 0;
	public int ironMade = 0;
	public int manaMade = 0;
	public int hideMade = 0;
	public int leatherMade = 0;
	public int firewoodMade = 0;
	public int planksMade = 0;
	public int bricksMade = 0;
	public int ironbarsMade = 0;
	public int arrowsMade = 0;
	public int bowsMade = 0;
	public int armorMade = 0;
	public int weaponsMade = 0;
	public int potionsMade = 0;

	//storage. How much is currently available of every resource
	public int food = 0;
	public int wood = 0;
	public int stone = 0;
	public int iron = 0;
	public int mana = 0;
	public int hide = 0;
	public int leather = 0;
	public int firewood = 0;
	public int planks = 0;
	public int bricks = 0;
	public int ironbars = 0;
	public int arrows = 0;
	public int bows = 0;
	public int armor = 0;
	public int weapons = 0;
	public int potions = 0;

	//jobs needed and jobs filled. Some standard jobs, some based off resources and need.
	public int monarchJobsNeeded = 0;
	public int monarchJobsFilled = 0;
	public int mayorJobsNeeded = 1;
	public int mayorJobsFilled = 0;
	public int tavernJobNeeded = 1;
	public int tavenJobFilled = 0;
	public int marketSellerNeeded = 1;
	public int marketSellerFilled = 0;

	//resource jobs
	public int farmerJobsNeeded = 0;
	public int farmerJobsFilled = 0;
	public int hunterJobsNeeded = 0;
	public int hunterJobsFilled = 0;
	public int lumberJobsNeeded = 0;
	public int lumberJobsFilled = 0;
	public int fishingJobsNeeded = 0;
	public int fishingJobsFilled = 0;
	public int minerJobsNeeded = 0;
	public int minerJobsFilled = 0;
	public int mageJobsNeeded = 0;
	public int mageJobsFilled = 0;

	//craftsmen jobs
	public int smithJobsNeeded = 0;
	public int smithJobsFilled = 0;
	public int stonemasonJobsNeeded = 0;
	public int stonemasonJobsFilled = 0;
	public int woodworkerJobsNeeded = 0;
	public int woodworkerJobsFilled = 0;
	public int smelterJobsNeeded = 0;
	public int smelterJobsFilled = 0;
	public int fletcherJobsNeeded = 0;
	public int fletcherJobsFilled = 0;
	public int bowyerJobsNeeded = 0;
	public int bowyerJobsFilled = 0;
	public int leatherworkerJobsNeeded = 0;
	public int leatherworkerJobsFilled = 0;
	public int blacksmithJobsNeeded = 0;
	public int blacksmithJobsFilled = 0;
	public int alchemistJobsNeeded = 0;
	public int alchemistJobsFilled = 0;
	public int expertwoodworkerJobsNeeded =0;
	public int expertwoodworkerJobsFilled = 0;
	public int expertleatherworkerJobsNeeded = 0;
	public int expertleatherworkerJobsFilled = 0;
	public int traderJobsNeeded = 0;
	public int traderJobsFilled = 0;
	public int guardJobsNeeded = 0;
	public int guardJobsFilled = 0;

	//somewhere to store raycasts as needed
	private RaycastHit hit;

	//store of all the nodes for connected towns. Currently limited to 1 until the pro version.
	public List<Vector3> nodes = new List<Vector3>(); 
	public GameObject goal;
	public GameObject road;
	public int paths = 0; //this is a place holder until I have a better way to track how many roads I need.



	//where it places/gets food from. Generate this at the end
	public List<Transform> foods = new List<Transform>();

	//info needed for generating town to walk in
	//village models and seed first
	//generate a seed to create randomness
	public int seed = 0;
	//list of buildings needed for the village
	public GameObject village1;
	public GameObject vhouse1;
	public GameObject vmarket1;
	public GameObject vtavern1;
	public GameObject vtownhall1;
	public GameObject vcrafts1;

	//list of all buildings for a town

	//list of all buildings for a city


	//debug to see where the towns are looking
	void OnDrawGizmosSelected() {
		Gizmos.color = Color.red;
		Gizmos.DrawWireSphere(this.transform.position,1.0f);
		Gizmos.DrawWireSphere(this.transform.position,size);
	}

	void Awake(){
		//need to add a condition where if there are any towns in tooClose we move somewhere else
		Collider[] tooClose = Physics.OverlapSphere(this.transform.position, size);
		Collider[] hitCollider = Physics.OverlapSphere(this.transform.position, 1.0f);

		foreach (var w in hitCollider){

			if (w.transform.name == "woods1(Clone)"){

				woods.Add(w.transform);
			}

			if (w.transform.name == "Grass(Clone)"){

				tiles.Add(w.transform);


				//check if you can place a farm here
				//currently also grabbing grass tiles under other tiles (i.e. villages, mountains, hills)
				if (Physics.Raycast(w.transform.position + new Vector3(0,2,0), Vector3.down, out hit, 3f)){

					if (hit.transform.name == "Grass(Clone)" || hit.transform.name == "Grass_Clutter1(Clone)"){
						foods.Add(hit.transform);
					}
				}
			}

			if (w.transform.name == "Water(Clone)"){

				water.Add(w.transform);
			}

			if (w.transform.name == "iron1(Clone)"){

				irons.Add(w.transform);
			}

			if (w.transform.name == "stone1(Clone)"){

				stones.Add(w.transform);
			}

			if (w.transform.name == "mana1(Clone)"){

				manas.Add(w.transform);
			}

			
		}

		pop = pop * size;
		//figure out food needs and jobs
		foodNeed = pop;
		unemployed = pop - monarchJobsNeeded - mayorJobsNeeded - tavernJobNeeded -  marketSellerNeeded;

		if (foodMade < foodNeed){

			//make hunters from woods if there are a lot of woods
			if (woods.Count > 2){

				hunterJobsNeeded = woods.Count - 2;
				hunterJobsFilled = woods.Count - 2;
				unemployed = unemployed - hunterJobsFilled;
				foodMade = hunterJobsFilled * 2;
			}


			//make fishermen if there is river nearby
			if (water.Count > 0){

					fishingJobsNeeded = water.Count;
					fishingJobsFilled = fishingJobsNeeded;
					unemployed = unemployed - fishingJobsFilled;
					foodMade = foodMade + fishingJobsFilled * 2;
				}


			//check if there is enough food now
			if(foodMade < foodNeed){
				
				farmerJobsNeeded = foodNeed/3 - foodMade/3;
				farmerJobsFilled = farmerJobsNeeded;
				unemployed = unemployed - farmerJobsFilled;
				foodMade = foodMade + farmerJobsFilled *3;

			}

		}
	

		//make resource jobs
		for (int i = 0; i < pop; i++) {

			//find how many of each job are needed
			lumberJobsNeeded = woods.Count;
			minerJobsNeeded = stones.Count*3 + irons.Count*3;
			mageJobsNeeded = manas.Count;

			//go through each job and fill one at a time

			if (lumberJobsFilled < lumberJobsNeeded){

				lumberJobsFilled++;
				unemployed--;
			}

			if (minerJobsFilled < minerJobsNeeded){

				minerJobsFilled++;
				unemployed--;
			}

			if (mageJobsFilled < mageJobsNeeded){

				mageJobsFilled++;
				unemployed--;
			}

			if (traderJobsFilled < traderJobsNeeded){

				traderJobsFilled++;
				unemployed--;
			}

			if (smithJobsFilled < smithJobsNeeded){

				smithJobsFilled++;
				unemployed--;
			}

			if (stonemasonJobsFilled < stonemasonJobsNeeded){

				stonemasonJobsFilled++;
				unemployed--;
			}

			if (woodworkerJobsFilled < woodworkerJobsNeeded){

				woodworkerJobsFilled++;
				unemployed--;
			}

			if (smelterJobsFilled < smelterJobsNeeded){

				smelterJobsFilled++;
				unemployed--;
			}

			if (fletcherJobsFilled < fletcherJobsNeeded){

				fletcherJobsFilled++;
				unemployed--;
			}

			if (bowyerJobsFilled < bowyerJobsNeeded){

				bowyerJobsFilled++;
				unemployed--;
			}

			if (leatherworkerJobsFilled < leatherworkerJobsNeeded){

				leatherworkerJobsFilled++;
				unemployed--;
			}

			if (blacksmithJobsFilled < blacksmithJobsNeeded){

				blacksmithJobsFilled++;
				unemployed--;
			}

			if (alchemistJobsFilled < alchemistJobsNeeded){

				alchemistJobsFilled++;
				unemployed--;
			}

			if (expertwoodworkerJobsFilled < alchemistJobsNeeded){

				expertwoodworkerJobsFilled++;
				unemployed--;
			}

			if (expertleatherworkerJobsFilled < alchemistJobsNeeded){

				expertleatherworkerJobsFilled++;
				unemployed--;
			}

			if (guardJobsFilled < guardJobsNeeded){

				guardJobsFilled++;
				unemployed--;
			}

	
		}

		//calculate the resources generated
		woodMade = woodMade + lumberJobsFilled *2;
		stoneMade = stoneMade + minerJobsFilled*stones.Count;
		ironMade = ironMade + minerJobsFilled * irons.Count;
		manaMade = manaMade + mageJobsFilled;
		hideMade = hunterJobsFilled;
		leatherMade = leatherworkerJobsFilled *hide + expertleatherworkerJobsFilled * hide;
		firewoodMade = lumberJobsFilled * 15;
		planksMade = woodworkerJobsFilled * wood/2;
		bricksMade = stonemasonJobsFilled * stone/2;
		ironbarsMade = smelterJobsFilled * iron/2;
		arrowsMade = fletcherJobsFilled * 10;
		bowsMade = bowyerJobsFilled;
		armorMade = blacksmithJobsFilled * ironbars;
		weaponsMade = blacksmithJobsFilled * ironbars;
		potionsMade = alchemistJobsFilled * mana;

		//calculate needs
		firewoodNeed = pop/2;
		leatherNeed = 0;


		/*
		foreach(var x in hitCollider){
			Debug.Log(x.transform.name);
		}
		*/	


		//road palcement goes here. For villages, they should find the nearest town, and connect a road to it.
		//they should also check to see if the city is close and connect to it.

		//towns need to check to see if they are connected to atleast two villages. If not, they should connect up.

		//the city should make connections to each town



		//spawn towntemplates
		spawnTownTemplates();
	}

    // Start is called before the first frame update
    void Start()
    {
        
    }




    // Update is called once per frame
    void Update()
    {
		//this currently will spawn one connection between two towns. I may be able to make multiple connections but changing the seeker target but not sure yet.
		//I need to fix the spawn so the object uses it's tail end as the center point. This should help with hills.
		//Alternatively, I can come up with different tiles for hills and turns.
		//turns are currently not connected up and hills are not visually connecting. AI can still traverse them.
		if (paths == 0) {
			//set the destination in the seeker script and make a path
			var seeker = gameObject.GetComponent<Seeker> ();
			Path p = seeker.StartPath (gameObject.transform.position, goal.transform.position);
			//wait until the path is calculated
			p.BlockUntilCalculated ();

			//make a list of the nodes that make up the path
			nodes = p.vectorPath;

			//spawn a road at each node facing the next node
			for (int n = 1; n < nodes.Count - 1; n++) {
				var a=	Instantiate (road, nodes [n] + new Vector3(0f,.01f,0f), Quaternion.identity);
				a.transform.LookAt (nodes[n+1]);
				a.transform.localEulerAngles = a.transform.localEulerAngles - (new Vector3 (0f, 60f, 0f));
			}
			//increas this to stop making paths. Currently a placeholder.
			paths++;

		}
    }

	void spawnTownTemplates(){
		//villages
		if (size == 1) {

			var template = Instantiate (village1, new Vector3 (510f, 0f, 40), Quaternion.identity);
			foreach (Transform child in template.transform) {
				if (child.tag == "House") {

					var house = Instantiate (vhouse1, child.transform.position, child.transform.rotation);
					house.transform.parent = template.transform;
					//print ("place a house");
				}

				if (child.tag == "Tavern") {
					var tavern = Instantiate (vtavern1, child.transform.position, child.transform.rotation);
					tavern.transform.parent = template.transform;
					//print ("place a tavern");
				}

				if (child.tag == "Crafts") {
					var craft = Instantiate (vcrafts1, child.transform.position, child.transform.rotation);
					craft.transform.parent = template.transform;
					//print ("place a craft");
				}

				if (child.tag == "Market") {
					var market = Instantiate (vmarket1, child.transform.position, child.transform.rotation);
					market.transform.parent = template.transform;
					//print ("place a market");
				}

				if (child.tag == "Townhall") {
					var townhall = Instantiate (vtownhall1, child.transform.position, child.transform.rotation);
					townhall.transform.parent = template.transform;
					//print ("place a townhall");
				}

			}

		}


		//towns



		//cities
	}



}
